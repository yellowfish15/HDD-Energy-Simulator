import math
import numpy as np
import pickle

# busy period interval length: generated by N(mu_busy, sigma_busy)
# idle period interval length: generated by N(mu_idle, sigma_idle)
def gen_normal(mu_busy, sigma_busy, mu_idle, sigma_idle, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = 0
        if b == 1:
            sz = max(1, int(np.random.normal(mu_busy, sigma_busy)))
        else:
            sz = max(1, int(np.random.normal(mu_idle, sigma_idle)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by EXP(lmbda)
def gen_exp(mu, sigma, lmbda, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = max(1, int(np.random.normal(mu, sigma) if b == 1 else np.random.default_rng().exponential(scale=lmbda)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by N(mu^-1, sigma)
def gen_long_short(mu, sigma, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = 0
        if b == 1:
            sz = max(1, int(np.random.normal(mu, sigma)))
        else:
            k = mu/intervals[len(intervals)-1]
            sz = max(1, int(np.random.normal(k*k*mu, sigma)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by a*sin(t/k) where a is amplitude and k is wavelength constant
def gen_periodic(mu_busy, sigma_busy, a, k, milliseconds):
    intervals = []
    t_idx = 1
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = 0
        if b == 1: # busy interval (normally distributed)
            sz = max(1, int(np.random.normal(mu_busy, sigma_busy)))
        else: # idle interval
            sz = int(abs(a*math.sin(t_idx/k)))
            t_idx += 1
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


'''
Serialize workload files
'''

# --- Workloads for HDD A ---
# workload created from normal distributions
with open("./workloads/HDD_A/normal.pickle", "wb") as f:
    pickle.dump(gen_normal(20000, 2000, 20000, 1500, 36000000), f)
# workload created from exponential distribution of idle period lengths
with open("./workloads/HDD_A/exponential.pickle", "wb") as f:
    pickle.dump(gen_exp(20000, 2000, 15000, 36000000), f)
# workload created from long/short normal distributions
with open("./workloads/HDD_A/long_short.pickle", "wb") as f:
    pickle.dump(gen_long_short(15000, 1000, 36000000), f) 
# workload created from periodic normal distributions
with open("./workloads/HDD_A/periodic.pickle", "wb") as f:
    pickle.dump(gen_periodic(15000, 1000, 15000, math.pi, 36000000), f)


# --- Workloads for HDD B ---
# workload created from normal distributions
with open("./workloads/HDD_B/normal.pickle", "wb") as f:
    pickle.dump(gen_normal(20000, 1000, 35000, 1500, 36000000), f)
# workload created from exponential distribution of idle period lengths
with open("./workloads/HDD_B/exponential.pickle", "wb") as f:
    pickle.dump(gen_exp(20000, 1000, 35000, 36000000), f)
# workload created from long/short normal distributions
with open("./workloads/HDD_B/long_short.pickle", "wb") as f:
    pickle.dump(gen_long_short(25000, 2000, 36000000), f) 
# workload created from periodic normal distributions
with open("./workloads/HDD_B/periodic.pickle", "wb") as f:
    pickle.dump(gen_periodic(25000, 2000, 60000, math.pi, 36000000), f)


# --- Workloads for HDD C ---
# workload created from normal distributions
with open("./workloads/HDD_C/normal.pickle", "wb") as f:
    pickle.dump(gen_normal(10000, 1000, 132000, 2000, 36000000), f)
# workload created from exponential distribution of idle period lengths
with open("./workloads/HDD_C/exponential.pickle", "wb") as f:
    pickle.dump(gen_exp(10000, 1000, 132000, 36000000), f)
# workload created from long/short normal distributions
with open("./workloads/HDD_C/long_short.pickle", "wb") as f:
    pickle.dump(gen_long_short(100000, 3000, 36000000), f) 
# workload created from periodic normal distributions
with open("./workloads/HDD_C/periodic.pickle", "wb") as f:
    pickle.dump(gen_periodic(10000, 1000, 150000, math.pi, 36000000), f)

WORKLOADS = ["normal", "exponential", "long_short", "periodic"]
