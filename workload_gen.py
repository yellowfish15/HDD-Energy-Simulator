import math
import numpy as np
import pickle

# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by N(mu, sigma)
def gen_normal(mu, sigma, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = max(1, int(np.random.normal(mu, sigma)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by EXP(lmbda)
def gen_exp(mu, sigma, lmbda, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = max(1, int(np.random.normal(mu, sigma) if b == 1 else np.random.default_rng().exponential(scale=lmbda)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by N(mu^-1, sigma)
def gen_long_short(mu, sigma, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = 0
        if b == 1:
            sz = max(1, int(np.random.normal(mu, sigma)))
        else:
            k = mu/intervals[len(intervals)-1]
            sz = max(1, int(np.random.normal(k*k*mu, sigma)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by mu*sin(t/k)
def gen_periodic(mu, sigma, k, milliseconds):
    intervals = []
    t_idx = 1
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = 0
        if b == 1: # busy interval (normally distributed)
            sz = max(1, int(np.random.normal(mu, sigma)))
        else: # idle interval
            sz = int(abs(mu*math.sin(t_idx/k)))
            t_idx += 1
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals

# Workloads for HDD A
norm_wkld = gen_normal(15000, 3000, 36000000) # workload created from normal distributions
exp_wkld = gen_exp(15000, 1000, 510, 36000000) # workload created from exponential distribution of idle period lengths
ls_wkld = gen_long_short(15000, 100, 36000000) # workload created from long/short normal distributions
periodic_wkld = gen_periodic(15000, 100, math.pi, 36000000) # workload created from periodic normal distributions

# serialize workload file
with open("wrkld", "wb") as f:
    pickle.dump(norm_wkld, f)
