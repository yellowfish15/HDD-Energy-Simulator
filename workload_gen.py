import numpy as np
import pickle

# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by N(mu, sigma)
def gen_normal(mu, sigma, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = max(1, int(np.random.normal(mu, sigma)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by EXP(lmbda)
def gen_exp(mu, sigma, lmbda, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = max(1, int(np.random.normal(mu, sigma) if b == 1 else np.random.default_rng().exponential(scale=lmbda)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


# busy period interval length: generated by N(mu, sigma)
# idle period interval length: generated by
def gen_long_short(mu, sigma, milliseconds):
    intervals = []
    b = 1 # 1=busy,-1=idle
    while milliseconds > 0:
        sz = 0
        if b == 1:
            sz = max(1, int(np.random.normal(mu, sigma)))
        else:
            k = mu/intervals[len(intervals)-1]
            sz = max(1, int(np.random.normal(k*k*mu, sigma)))
        if sz > milliseconds:
            sz = milliseconds
        intervals.append(sz*b)
        milliseconds -= sz
        b *= -1
    return intervals


norm_wkld = gen_normal(20000, 5000, 36000000) # workload created from normal distributions
exp_wkld = gen_exp(20000, 5000, 20000, 36000000) # workload created from exponential distribution of idle period lengths
ls_wkld = gen_long_short(20000, 5000, 36000000) # workload created from long/short normal distributions

# serialize workload file
with open("wrkld", "wb") as f:
    pickle.dump(norm_wkld, f)
